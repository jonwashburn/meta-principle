import MetaPrinciple.Recognition.Ledger.Core
import Mathlib.GroupTheory.FreeAbelianGroup
import Mathlib.Algebra.QuotientGroup

namespace MetaPrinciple

/-!
  T1 uniqueness roadmap: build a ledger carrier as a quotient of the free abelian group on oriented edges
  by identifying symmetric pairs. Define a positive cone generated by oriented edges and use it to equip
  the carrier with a linear order. Finally, show uniqueness up to order‑isomorphism under conservation.
-/

open FreeAbelianGroup

variable {M : RecognitionStructure}

/-- Oriented edges of `M`. -/
abbrev Edge (M : RecognitionStructure) := M.U × M.U

namespace Edge
  def symm (e : Edge M) : Edge M := (e.2, e.1)
end Edge

/-- Free abelian group on oriented edges. -/
abbrev F := FreeAbelianGroup (Edge M)

/-- Symmetric relation identifying `[a→b] + [b→a] = 0`. Encoded as a subgroup to quotient by. -/
def SymPairsSet : Set F :=
  {x | ∃ (a b : M.U), M.recog a b ∧ M.recog b a ∧ x = (FreeAbelianGroup.of (a,b) + FreeAbelianGroup.of (b,a))}

def SymPairsSubgroup : AddSubgroup F := AddSubgroup.closure (SymPairsSet : Set F)

/-- Quotient carrier for the ledger. -/
abbrev Carrier := QuotientAddGroup.Quotient (SymPairsSubgroup : AddSubgroup F)

/-- Positive cone generated by classes of oriented edges. (Sketch placeholder.) -/
def PositiveCone : Set Carrier :=
  { q | ∃ (n : Nat) (es : Fin n → Edge M), (∀ i, M.recog (es i).1 (es i).2)
                 ∧ q =
                    QuotientAddGroup.mk (SymPairsSubgroup) (
                      (Fin.fold (fun acc i => acc + FreeAbelianGroup.of (es i)) 0 n) : F) }

lemma pos_zero : PositiveCone (M:=M) (0 : Carrier) := by
  classical
  refine ⟨0, (fun i => (Classical.arbitrary (Edge M))), ?_, ?_⟩
  · intro i; cases i.elim0
  · simp

lemma pos_add {a b : Carrier}
  (ha : PositiveCone (M:=M) a) (hb : PositiveCone (M:=M) b) :
  PositiveCone (M:=M) (a + b) := by
  classical
  rcases ha with ⟨n, es, hes, ha⟩
  rcases hb with ⟨m, fs, hfs, hb⟩
  refine ⟨n + m, (fun i => if h : (i.val < n) then es ⟨i.val, by exact Nat.lt_of_lt_of_le (by simpa using h) (Nat.le.intro rfl)⟩ else fs ⟨i.val - n, by exact Nat.sub_lt_of_pos_le (by decide) (Nat.le.intro rfl)⟩), ?_, ?_⟩
  · intro i; by_cases h : i.val < n
    · have : ∀ j, M.recog (es j).1 (es j).2 := hes; simpa [dif_pos h]
    · have : ∀ j, M.recog (fs j).1 (fs j).2 := hfs; simpa [dif_neg h]
  · -- Sum splits over the two blocks (outline)
    simpa [ha, hb]

/-- Order structure (placeholder) to be refined to an Archimedean ordered abelian group. -/
-- Order via positive cone: a ≤ b if b - a ∈ PositiveCone (informal; placeholder here)
def leCarrier (a b : Carrier) : Prop := PositiveCone (M:=M) (b + (-a))

instance : LE Carrier := ⟨leCarrier⟩

instance : Preorder Carrier :=
{ le := (· ≤ ·)
, le_refl := by
    intro a
    change PositiveCone (M:=M) (a + -a)
    simpa using pos_zero (M:=M)
, le_trans := by
    intro a b c hab hbc
    change PositiveCone (M:=M) (c + -a) at *
    -- (c - b) + (b - a) = (c - a)
    have : c + -a = (c + -b) + (b + -a) := by abel_nf
    -- closure under addition
    simpa [this] using pos_add (M:=M) hbc hab }

/-- Archimedean property for the quotient carrier (placeholder statement). -/
theorem archimedean_carrier : True := by
  -- Archimedean property holds due to finitary generation of positive cone (outline)
  trivial

/-- Induced ledger from the quotient carrier (skeleton). -/
def quotientLedger (M : RecognitionStructure) : Ledger M Carrier :=
{ delta := QuotientAddGroup.mk (SymPairsSubgroup) (0 : F)
, delta_pos := by trivial
, debit := fun _ => QuotientAddGroup.mk (SymPairsSubgroup) (0 : F)
, credit := fun _ => QuotientAddGroup.mk (SymPairsSubgroup) (0 : F)
, de := by intro _ _ _; trivial }

noncomputable def edgeWeight
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) (e : Edge M) : C := by
  classical
  by_cases h : M.recog e.1 e.2
  by_cases h' : M.recog e.2 e.1
  -- both directions recognized → assign 0 for anti-symmetry of pair sum
  · exact 0
  -- only forward direction
  · exact L.delta
  -- only backward direction
  · exact - L.delta
  -- neither direction
  · exact 0

/-- Universal homomorphism from free abelian group on edges to any ledger's carrier. -/
noncomputable def liftToLedger
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) : F →+ C :=
  FreeAbelianGroup.lift (edgeWeight (M:=M) (L:=L))

lemma symPairs_in_ker
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) :
  SymPairsSubgroup ≤ (AddMonoidHom.ker (liftToLedger (M:=M) (L:=L))) := by
  -- Every generator maps to 0; closure induction extends to the subgroup
  classical
  refine AddSubgroup.closure_le.mpr ?goal
  intro x hx
  rcases hx with ⟨a, b, hab, hba, rfl⟩
  -- Image under lift is edgeWeight (a,b) + edgeWeight (b,a) = 0
  simp [liftToLedger, FreeAbelianGroup.lift, edgeWeight, hab, hba, AddMonoidHom.mem_ker]

/-- Induced hom from the quotient carrier into any ledger carrier. -/
noncomputable def fromQuotient
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) : Carrier →+ C :=
  QuotientAddGroup.lift _ (liftToLedger (M:=M) (L:=L)) (by
    -- kernel contains symmetric pairs → map descends to the quotient
    intro x hx
    have hle := symPairs_in_ker (M:=M) (L:=L)
    exact hle hx)

/-- Uniqueness up to order‑isomorphism: statement placeholder. -/
theorem uniqueness_up_to_orderIso
  {C₁ C₂ : Type} [LinearOrderedAddCommGroup C₁] [LinearOrderedAddCommGroup C₂]
  (L₁ : Ledger M C₁) (L₂ : Ledger M C₂)
  [Conserves L₁] [Conserves L₂]
  : True := by
  -- Use `fromQuotient` to obtain canonical maps to both carriers and transport the order.
  -- Show they are mutually inverse up to order, yielding an order isomorphism (outline).
  trivial

/-- Canonical order-preserving map from the quotient to any ledger. -/
noncomputable def toLedgerOrderPreserving
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) : Carrier → C := fun q => (fromQuotient (M:=M) (L:=L)) q


end MetaPrinciple
