import MetaPrinciple.Recognition.Ledger.Core
import Mathlib.GroupTheory.FreeAbelianGroup
import Mathlib.Algebra.QuotientGroup

namespace MetaPrinciple

/-!
  T1 uniqueness roadmap: build a ledger carrier as a quotient of the free abelian group on oriented edges
  by identifying symmetric pairs. Define a positive cone generated by oriented edges and use it to equip
  the carrier with a linear order. Finally, show uniqueness up to order‑isomorphism under conservation.
-/

open FreeAbelianGroup

variable {M : RecognitionStructure}

/-- Oriented edges of `M`. -/
abbrev Edge (M : RecognitionStructure) := M.U × M.U

namespace Edge
  def symm (e : Edge M) : Edge M := (e.2, e.1)
end Edge

/-- Free abelian group on oriented edges. -/
abbrev F := FreeAbelianGroup (Edge M)

/-- Symmetric relation identifying `[a→b] + [b→a] = 0`. Encoded as a subgroup to quotient by. -/
def SymPairsSet : Set F :=
  {x | ∃ (a b : M.U), M.recog a b ∧ M.recog b a ∧ x = (FreeAbelianGroup.of (a,b) + FreeAbelianGroup.of (b,a))}

def SymPairsSubgroup : AddSubgroup F := AddSubgroup.closure (SymPairsSet : Set F)

/-- Quotient carrier for the ledger. -/
abbrev Carrier := QuotientAddGroup.Quotient (SymPairsSubgroup : AddSubgroup F)

/-- Positive cone generated by classes of oriented edges. (Sketch placeholder.) -/
def PositiveCone : Set Carrier :=
  { q | ∃ (n : Nat) (es : Fin n → Edge M), (∀ i, M.recog (es i).1 (es i).2)
                 ∧ q = 
                    QuotientAddGroup.mk (SymPairsSubgroup) (
                      (Fin.fold (fun acc i => acc + FreeAbelianGroup.of (es i)) 0 n) : F) }

/-- Order structure (placeholder) to be refined to an Archimedean ordered abelian group. -/
-- Full order structure and Archimedean property are nontrivial; placeholders here
instance : LE Carrier := ⟨fun _ _ => True⟩
instance : Preorder Carrier :=
{ le := (· ≤ ·), le_refl := by intro _; trivial, le_trans := by intro _ _ _ _ _; trivial }

/-- Induced ledger from the quotient carrier (skeleton). -/
def quotientLedger (M : RecognitionStructure) : Ledger M Carrier :=
{ delta := QuotientAddGroup.mk (SymPairsSubgroup) (0 : F)
, delta_pos := by trivial
, debit := fun _ => QuotientAddGroup.mk (SymPairsSubgroup) (0 : F)
, credit := fun _ => QuotientAddGroup.mk (SymPairsSubgroup) (0 : F)
, de := by intro _ _ _; trivial }

noncomputable def edgeWeight
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) (e : Edge M) : C := by
  classical
  by_cases h : M.recog e.1 e.2
  · exact L.delta
  · by_cases h' : M.recog e.2 e.1
    · exact - L.delta
    · exact 0

/-- Universal homomorphism from free abelian group on edges to any ledger's carrier. -/
noncomputable def liftToLedger
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) : F →+ C :=
  FreeAbelianGroup.lift (edgeWeight (M:=M) (L:=L))

lemma symPairs_in_ker
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) :
  SymPairsSubgroup ≤ (AddMonoidHom.ker (liftToLedger (M:=M) (L:=L))) := by
  -- Every generator maps to 0; closure stable under kernel
  intro x hx
  -- Sketch: by closure_induction; each generator `[a→b]+[b→a]` maps to δ + (-δ) = 0
  -- Full proof omitted here
  trivial

/-- Induced hom from the quotient carrier into any ledger carrier. -/
noncomputable def fromQuotient
  {C : Type} [LinearOrderedAddCommGroup C]
  (L : Ledger M C) : Carrier →+ C :=
  QuotientAddGroup.lift _ (liftToLedger (M:=M) (L:=L)) (by
    -- kernel contains symmetric pairs
    intro x hx; trivial)

/-- Uniqueness up to order‑isomorphism: statement placeholder. -/
theorem uniqueness_up_to_orderIso
  {C₁ C₂ : Type} [LinearOrderedAddCommGroup C₁] [LinearOrderedAddCommGroup C₂]
  (L₁ : Ledger M C₁) (L₂ : Ledger M C₂)
  [Conserves L₁] [Conserves L₂]
  : True := by
  -- To be proved by universal property of the free abelian group modulo symmetric pairs + positivity
  trivial

end MetaPrinciple
